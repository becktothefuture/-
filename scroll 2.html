<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Spaceship Thrusters & Starfield</title>
  <style>
    body {
      margin: 0;
      height: 10000vh; /* Very tall page for scrolling */
      overflow-x: hidden;
    }
    /* Fullscreen starfield canvas in the background */
    #starfield {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      z-index: -1;
      pointer-events: none;
    }
    /* Wrapper that holds all website content and will rumble */
    #wrapper {
      position: fixed;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
    }
    /* Centered demo content */
    .center {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      color: white;
      text-align: center;
      font-family: sans-serif;
    }
    /* Thruster indicator in bottom left */
    #thruster {
      position: fixed;
      bottom: 3vh;
      left: 3vh;
      width: 6vh;
      height: 2vh;
      background-color: rgba(3, 255, 255, 0.5);
      border-radius: 0.5vh;
      box-shadow: 0 0 0 0 transparent;
      z-index: 100;
      transform-origin: center left;
      will-change: transform, box-shadow, background-color; /* Optimization for animations */
    }
    /* Direction prompt popup */
    #direction-prompt {
      position: fixed;
      top: 20vh;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px 25px;
      border-radius: 8px;
      font-family: sans-serif;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 15px rgba(0, 100, 255, 0.5);
    }
    #direction-prompt.visible {
      opacity: 1;
    }
    /* Arrow up icon */
    .arrow-up {
      display: inline-block;
      width: 0; 
      height: 0; 
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 12px solid white;
      margin-right: 8px;
      vertical-align: middle;
    }
  </style>e
</head>
<body>
  <canvas id="starfield"></canvas>
  <div id="wrapper">
    <div class="center">
      <h1>Spaceship Thrusters</h1>
      <p>Scroll to accelerate through space.</p>
    </div>
  </div>
  
  <!-- Add thruster indicator -->
  <div id="thruster"></div>
  
  <!-- Add direction popup -->
  <div id="direction-prompt">
    <span class="arrow-up"></span>
    Scroll up to accelerate!
  </div>

  <script>
    // --- Performance-Optimized Variables ---
    const intensityMultiplier = 0.9;
    const maxIntensity = 20;
    const damping = 0.98; 
    const minShakeThreshold = 1; 

    // --- Star Configuration ---
    const numStars = 800;       // Number of stars to render
    const maxDepth = 1500;      // How far back stars go in Z space
    const perspective = 500;    // Perspective factor for 3D projection
    const starSpeed = 2;        // Base speed of stars
    const starSpread = 2000;    // How wide the stars spread (-starSpread/2 to starSpread/2)
    
    // Star appearance
    const baseStarSize = 2;     // Base size multiplier for stars
    const minStarSize = 0.5;    // Minimum star size in pixels
    const starColorBase = 200;  // Base RGB value (higher = whiter)
    const starColorRange = 55;  // Random RGB range to add to base

    let shakeIntensity = 0;
    let lastScrollY = window.scrollY;
    let lastTime = performance.now();
    let scrollVelocity = 0;
    let scrollAcceleration = 0;
    let prevScrollVelocity = 0;

    const wrapper = document.getElementById('wrapper');
    const thruster = document.getElementById('thruster');
    const directionPrompt = document.getElementById('direction-prompt');
    let flickerIntensity = 0;
    let wrongDirectionTimer = null;

    // --- Optimized Scroll Event Handler ---
    // Use a flag to throttle scroll events
    let ticking = false;
    let lastScrollEvent = 0;
    const SCROLL_THROTTLE = 5; // ms

    // --- Optimized 3D Starfield with Object Pooling ---
    const canvas = document.getElementById('starfield');
    const ctx = canvas.getContext('2d', { alpha: false }); // Disable alpha for performance
    
    // Performance optimization - pre-allocate star array
    const stars = new Array(numStars);
    
    // Star object pool
    const starPool = [];
    const POOL_SIZE = numStars * 1.5; // 50% extra capacity for recycling

    // Create optimized star objects for the pool
    function createStar() {
      return {
        x: 0, 
        y: 0, 
        z: 0,
        color: 'rgb(255, 255, 255)',
        active: false
      };
    }

    // Initialize star pool
    function initStarPool() {
      for (let i = 0; i < POOL_SIZE; i++) {
        starPool.push(createStar());
      }
    }

    // Get star from pool
    function getStarFromPool() {
      for (let i = 0; i < starPool.length; i++) {
        if (!starPool[i].active) {
          starPool[i].active = true;
          return starPool[i];
        }
      }
      // If no available stars, create a new one
      const newStar = createStar();
      newStar.active = true;
      starPool.push(newStar);
      return newStar;
    }

    // Resize canvas with optimizations
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      // Pre-calculate center coordinates
      canvas.centerX = canvas.width / 2;
      canvas.centerY = canvas.height / 2;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Initialize stars with optimized pooling
    function initStars() {
      initStarPool();
      
      for (let i = 0; i < numStars; i++) {
        const star = getStarFromPool();
        
        // Random position with pre-defined spread
        star.x = (Math.random() * starSpread) - starSpread/2;
        star.y = (Math.random() * starSpread) - starSpread/2;
        star.z = Math.random() * maxDepth;
        
        // Precompute color for better performance
        const brightness = starColorBase + Math.random() * starColorRange;
        star.color = `rgb(${brightness}, ${brightness}, ${brightness})`;
        
        stars[i] = star;
      }
    }
    initStars();

    // Pre-allocate reusable object for calculations
    const starProjection = { x: 0, y: 0, prevX: 0, prevY: 0, size: 0, alpha: 0 };

    // Update and draw the 3D starfield with performance optimizations
    function updateAndDrawStarfield(speedMultiplier) {
      // Clear canvas - faster than fillRect
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Reference center coordinates
      const centerX = canvas.centerX;
      const centerY = canvas.centerY;
      
      // Batch similar operations for better performance
      const moveSpeed = starSpeed * speedMultiplier;
      
      // First pass - update all star positions (separate calculation from drawing)
      for (let i = 0; i < numStars; i++) {
        const star = stars[i];
        
        // Move star closer (decrease z)
        star.z -= moveSpeed;
        
        // If star is too close, reset it far away (recycling)
        if (star.z <= 0) {
          // Instead of creating new objects, reuse existing ones
          star.z = maxDepth;
          star.x = (Math.random() * starSpread) - starSpread/2;
          star.y = (Math.random() * starSpread) - starSpread/2;
          
          // Precompute color for better performance
          const brightness = starColorBase + Math.random() * starColorRange;
          star.color = `rgb(${brightness}, ${brightness}, ${brightness})`;
        }
      }
      
      // Second pass - draw all stars (batch rendering)
      for (let i = 0; i < numStars; i++) {
        const star = stars[i];
        
        // Project 3D position to 2D screen position using perspective (reuse object)
        const scale = perspective / star.z;
        starProjection.x = centerX + star.x * scale;
        starProjection.y = centerY + star.y * scale;
        
        // Calculate previous position for line (motion trail)
        const prevZ = star.z + moveSpeed;
        const prevScale = perspective / prevZ;
        starProjection.prevX = centerX + star.x * prevScale;
        starProjection.prevY = centerY + star.y * prevScale;
        
        // Star size and alpha based on distance (closer = larger & brighter)
        starProjection.size = Math.max(minStarSize, baseStarSize * (1 - star.z / maxDepth));
        starProjection.alpha = Math.min(1, 1 - (star.z / maxDepth) * 0.8);
        
        // Draw star as a line with motion trail - batch similar drawing operations
        ctx.beginPath();
        ctx.moveTo(starProjection.prevX, starProjection.prevY);
        ctx.lineTo(starProjection.x, starProjection.y);
        ctx.strokeStyle = star.color;
        ctx.globalAlpha = starProjection.alpha;
        ctx.lineWidth = starProjection.size;
        ctx.stroke();
        
        // Draw point with a single operation
        ctx.beginPath();
        ctx.arc(starProjection.x, starProjection.y, starProjection.size * 1.5, 0, 2 * Math.PI);
        ctx.fillStyle = star.color;
        ctx.fill();
      }
      
      // Reset global alpha once at the end
      ctx.globalAlpha = 1;
    }

    // --- Optimized Scroll Event Listener ---
    window.addEventListener('scroll', () => {
      const now = performance.now();
      
      // Throttle scroll events for better performance
      if (now - lastScrollEvent < SCROLL_THROTTLE) {
        if (!ticking) {
          requestAnimationFrame(() => {
            handleScroll();
            ticking = false;
          });
          ticking = true;
        }
        return;
      }
      
      lastScrollEvent = now;
      handleScroll();
    });

    function handleScroll() {
      const currentScrollY = window.scrollY;
      const currentTime = performance.now();
      let deltaTime = currentTime - lastTime;
      
      // Safety check for time delta
      if (deltaTime < 10) deltaTime = 10;
      
      // Improved scroll reset detection with buffer
      const scrollHeight = Math.max(
        document.body.scrollHeight,
        document.documentElement.scrollHeight
      );
      const viewportHeight = window.innerHeight;
      const buffer = 10;
      
      // Reset when reaching the top of the page
      if (window.scrollY <= buffer) {
        window.scrollTo({
          top: scrollHeight - viewportHeight,
          behavior: 'auto'
        });
        lastScrollY = scrollHeight - viewportHeight;
        lastTime = currentTime;
        shakeIntensity = 0;
        scrollVelocity = 0;
        scrollAcceleration = 0;
        prevScrollVelocity = 0;
        return;
      }

      // Physics-based dampening calculations
      const deltaY = currentScrollY - lastScrollY;
      
      // Calculate instantaneous velocity
      const instantVelocity = deltaY / deltaTime * 1000;
      
      // Calculate acceleration (rate of velocity change)
      prevScrollVelocity = scrollVelocity;
      
      // Apply low-pass filter for smoother velocity
      scrollVelocity = scrollVelocity * 0.8 + instantVelocity * 0.2;
      
      // Calculate acceleration from velocity change
      scrollAcceleration = (scrollVelocity - prevScrollVelocity) / deltaTime * 1000;
      
      // Check for upward scrolling (negative deltaY)
      if (deltaY < 0) {
        // Convert negative velocity to positive intensity
        const absVelocity = Math.abs(scrollVelocity);
        const velocityFactor = Math.min(maxIntensity, absVelocity * intensityMultiplier);
        
        // Add acceleration component for more responsive feel
        const accelBoost = Math.min(5, Math.abs(scrollAcceleration) * 0.01);
        const newIntensity = velocityFactor + accelBoost;
        
        // Update shake intensity with smoother transitions
        shakeIntensity = Math.max(shakeIntensity, newIntensity);
        
        // Add flicker based on both velocity and acceleration for more dynamic effect
        flickerIntensity = Math.min(1, absVelocity / 300 + Math.abs(scrollAcceleration) / 1000);
        
        // Hide the direction prompt when scrolling correctly
        hideDirectionPrompt();
      } else {
        // For downward scrolling, show direction prompt
        showDirectionPrompt();
        
        // Apply minimal dampening to maintain some effect
        shakeIntensity *= 0.95;
        flickerIntensity *= 0.95;
      }

      lastScrollY = currentScrollY;
      lastTime = currentTime;
    }
    
    // Show direction prompt with auto-hide after delay
    function showDirectionPrompt() {
      directionPrompt.classList.add('visible');
      
      // Clear any existing timers to avoid multiple timers
      if (wrongDirectionTimer) {
        clearTimeout(wrongDirectionTimer);
      }
      
      // Auto-hide after 2 seconds
      wrongDirectionTimer = setTimeout(() => {
        hideDirectionPrompt();
      }, 2000);
    }
    
    // Hide direction prompt
    function hideDirectionPrompt() {
      directionPrompt.classList.remove('visible');
      
      if (wrongDirectionTimer) {
        clearTimeout(wrongDirectionTimer);
        wrongDirectionTimer = null;
      }
    }

    // --- Optimized Animation Loop with Time-Based Movement ---
    let lastFrameTime = performance.now();
    let frameDelta = 0;

    function animate(timestamp) {
      // Calculate precise time between frames
      frameDelta = timestamp - lastFrameTime;
      lastFrameTime = timestamp;
      
      // Normalize frame rate for consistent speed
      const frameCorrection = frameDelta / 16.67; // Target: 60fps
      
      // Apply natural dampening even without scroll input - adjusted to respect frame rate
      const timeAdjustedDamping = Math.pow(damping, frameCorrection);
      shakeIntensity *= timeAdjustedDamping;
      flickerIntensity *= timeAdjustedDamping;
      
      // Map shakeIntensity to starfield speed (1-10 for more dramatic effect)
      const currentStarfieldSpeed = 1 + (shakeIntensity / maxIntensity) * 9;
      
      // Update starfield with time-based adjustment
      updateAndDrawStarfield(currentStarfieldSpeed * frameCorrection);

      // Enhanced rumble effect with time-based intensity
      if (shakeIntensity > minShakeThreshold) {
        // Add variance to the shake direction with frame-normalized intensity
        const shakeFactor = shakeIntensity * frameCorrection * 0.1;
        const offsetX = (Math.random() * 2 - 1) * shakeFactor;
        const offsetY = (Math.random() * 2 - 1) * shakeFactor;
        
        // Add minor rotation for more realistic thruster effect
        const rotation = (Math.random() * 2 - 1) * shakeFactor * 0.2;
        
        // Use hardware-accelerated transforms
        wrapper.style.transform = `translate3d(${offsetX}px, ${offsetY}px, 0) rotate(${rotation}deg)`;
      } else {
        wrapper.style.transform = 'translate3d(0, 0, 0)';
      }
      
      // High-fidelity thruster visualization with enhanced flicker
      if (shakeIntensity > 0) {
        // Enhanced visual effects
        const normalizedIntensity = Math.min(1, shakeIntensity / maxIntensity);
        
        // Dynamic color shift based on intensity (purple to white)
        const hue = 270 - normalizedIntensity * 30; // Shift from purple toward blue-white
        const sat = 80 - normalizedIntensity * 70; // Reduce saturation as intensity increases
        const lightness = 70 + normalizedIntensity * 30; // Increase brightness with intensity
        
        // Advanced flicker with varying frequency based on intensity
        const flickerBase = flickerIntensity * (0.6 + Math.random() * 0.4);
        const fastFlicker = Math.random() > 0.7 ? (Math.random() * 0.3) : 0;  // Occasional fast flickers
        const flicker = flickerBase + fastFlicker;
        
        // Combine base glow with flicker effect
        const glowSize = (5 + normalizedIntensity * 25) * (0.8 + flicker * 0.2);
        const glowOpacity = 0.5 + normalizedIntensity * 0.5 + flicker * 0.2;
        
        // Apply physically accurate scaling based on power
        const scaleX = 1 + normalizedIntensity * 0.3 + flicker * 0.1;
        const scaleY = 1 + flicker * 0.05;
        
        // Apply combined effects with hardware acceleration
        thruster.style.transform = `scaleX(${scaleX}) scaleY(${scaleY})`;
        thruster.style.boxShadow = `0 0 ${glowSize}px ${glowSize/2}px hsla(${hue}, ${sat}%, ${lightness}%, ${glowOpacity})`;
        thruster.style.backgroundColor = `hsla(${hue}, ${sat + 10}%, ${lightness - 10}%, ${0.3 + normalizedIntensity * 0.7})`;
      } else {
        thruster.style.boxShadow = 'none';
        thruster.style.backgroundColor = 'rgba(180, 160, 220, 0.2)';
        thruster.style.transform = 'scaleX(1) scaleY(1)';
      }

      requestAnimationFrame(animate);
    }
    
    // Start animation loop with timestamp
    requestAnimationFrame(animate);
  </script>
</body>
</html>